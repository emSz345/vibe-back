const express = require('express');
const router = express.Router();
const { InferenceClient } = require('@huggingface/inference');
const Event = require('../models/Event');

// Inicializar cliente do Hugging Face com a nova API
const client = new InferenceClient(process.env.HF_TOKEN);

// Sistema de prompts e contexto
const SYSTEM_PROMPT = `
Voc√™ √© o "Vibe Bot", um assistente virtual especializado em eventos da plataforma NaVibe Eventos.

REGRA ABSOLUTA: Sua resposta deve conter APENAS o texto final para o usu√°rio. 
NUNCA inclua JSON, chaves {}, tags <think>, <reasoning>, ou qualquer conte√∫do interno de pensamento.
NUNCA explique seu processo de racioc√≠nio na resposta final.

FORMATO PROIBIDO: 
- N√£o use {"s": "pensamento", "answer": "resposta"}
- N√£o use <think>pensamento</think>
- N√£o use Racioc√≠nio: texto

FORMATO PERMITIDO:
- Apenas texto puro com a resposta amig√°vel
- Pode usar emojis e markdown b√°sico
- Seja direto e natural

EXEMPLOS ERRADOS:
{"s": "pensamento", "answer": "resposta"}
<think>pensamento</think>resposta
Racioc√≠nio: pensamento ‚Üí resposta

EXEMPLOS CORRETOS:
Encontrei 2 eventos dispon√≠veis! üéâ

EXEMPLOS CORRETOS PARA PRE√áO:
Usu√°rio: "eventos mais baratos em sp"
Resposta: "Encontrei os 3 eventos mais baratos de SP! üéâ\n\n‚Ä¢ SHKL - R$ 100,00\n‚Ä¢ Evento X - R$ 120,00\n‚Ä¢ Evento Y - R$ 150,00"

Usu√°rio: "qual o evento mais barato?"
Resposta: "O evento mais barato no momento √© SHKL por R$ 100,00! üé™"

Sua fun√ß√£o √© ajudar usu√°rios a:
- Encontrar eventos por categoria, localiza√ß√£o, data, pre√ßo
- Explicar como comprar ingressos
- Ajudar com cria√ß√£o de eventos
- Responder sobre perfis de usu√°rio
- Fornecer informa√ß√µes sobre o sistema
- Gerenciar carrinho de compras (adicionar, remover, listar, limpar, finalizar compra)

ESTILO DE RESPOSTA:
- Amig√°vel e empolgada (use emojis quando apropriado)
- Direta e √∫til
- Sempre relacionada ao contexto de eventos

INFORMA√á√ïES SOBRE O SISTEMA:
- Plataforma: NaVibe Eventos
- Categorias dispon√≠veis: Rock, Sertanejo, Eletr√¥nica, Pop, MPB, Forr√≥, Pagode, Jazz, Blues, Cl√°ssica, Teatro, Dan√ßa, Stand-up, Festival, Infantil, Esportes, Gastronomia, Workshop, Funk, Outros

FUNCIONALIDADES DE CARRINHO:
- Quando o usu√°rio pedir para ver o carrinho, liste os itens com pre√ßos
- Para remover itens, forne√ßa quick replies com a√ß√µes
- Sempre mostre o total do carrinho
- Para finalizar compra, redirecione para a p√°gina de carrinho

EXEMPLOS CORRETOS PARA CARRINHO:
Usu√°rio: "ver carrinho"
Resposta: "üõí Seu Carrinho:\n\n1. Show do Rock\n   üìÖ 15/12/2024\n   üé´ 2x R$ 50,00\n   üí∞ Subtotal: R$ 100,00\n\nüí∞ TOTAL: R$ 100,00"

Usu√°rio: "limpar carrinho"
Resposta: "üßπ Carrinho limpo! Todos os itens foram removidos."

Usu√°rio: "finalizar compra"
Resposta: "‚úÖ Te levando para finalizar sua compra... üöÄ"

\n\nIMPORTANTE FINAL: Responda APENAS com texto puro para o usu√°rio, como um assistente natural conversando.
`;

// Fun√ß√£o para buscar eventos no banco de dados
async function buscarEventos(filtros = {}) {
  try {
    let query = { status: 'aprovado' };

    // Normalizar categoria
    if (filtros.categoria) {
      const categoriaNormalizada = filtros.categoria.trim();
      query.categoria = new RegExp(`^${categoriaNormalizada}$`, 'i');
    }

    // Normalizar localiza√ß√£o - buscar por cidade OU estado
    if (filtros.localizacao) {
      const localizacao = filtros.localizacao.trim().toUpperCase();

      // Lista de siglas de estados
      const siglasEstados = ['AC', 'AL', 'AP', 'AM', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA',
        'MT', 'MS', 'MG', 'PA', 'PB', 'PR', 'PE', 'PI', 'RJ', 'RN',
        'RS', 'RO', 'RR', 'SC', 'SP', 'SE', 'TO'];

      // Se for uma sigla de estado (como "SP")
      if (siglasEstados.includes(localizacao)) {
        query.estado = localizacao;
      }
      // Se for no formato "cidade-estado"
      else if (localizacao.includes('-')) {
        const [cidade, estado] = localizacao.split('-').map(s => s.trim());
        if (estado) {
          query.estado = new RegExp(`^${estado}$`, 'i');
        }
        if (cidade && cidade !== estado) {
          query.cidade = new RegExp(`^${cidade}$`, 'i');
        }
      }
      // Se for apenas nome de cidade
      else {
        query.cidade = new RegExp(`^${localizacao}$`, 'i');
      }
    }

    // ‚úÖ ADICIONE ESTE BLOCO PARA VALOR ESPEC√çFICO
    if (filtros.valorEspecifico) {
      query.valorIngressoInteira = filtros.valorEspecifico;
    }

    // Filtro por faixa de pre√ßo
    else if (filtros.faixaPreco) {
      query.valorIngressoInteira = {
        $gte: filtros.faixaPreco.min || 0,
        $lte: filtros.faixaPreco.max || 1000
      };
    }

    console.log("üîç Query constru√≠da:", query);

    let eventosQuery = Event.find(query);

    if (filtros.intent === 'preco' || filtros.faixaPreco || filtros.valorEspecifico) {
      eventosQuery = eventosQuery.sort({ valorIngressoInteira: 1 });
    } else {
      eventosQuery = eventosQuery.sort({ dataInicio: 1 });
    }

    const limit = (filtros.intent === 'preco' || filtros.valorEspecifico) ? 3 : (filtros.quantidade || 10);
    const eventos = await eventosQuery.limit(limit);

    console.log("üéâ Eventos retornados:", eventos.length);
    return eventos;
  } catch (error) {
    console.error('Erro ao buscar eventos:', error);
    return [];
  }
}

function extrairValorMonetario(mensagem) {
  const regexValor = /(?:R\$\s*)?(\d+[\.,]?\d*)(?:\s*reais)?/i;
  const match = mensagem.match(regexValor);

  if (match && match[1]) {
    // Converter para n√∫mero (substituir v√≠rgula por ponto se necess√°rio)
    const valor = parseFloat(match[1].replace(',', '.'));
    return isNaN(valor) ? null : valor;
  }
  return null;
}

// Extrair inten√ß√µes e par√¢metros da mensagem do usu√°rio
function analisarMensagem(mensagem) {
  const mensagemLower = mensagem.toLowerCase();

  const intencoes = {
    saudacao: /(ol√°|oi|e a√≠|bom dia|boa tarde|boa noite|hello|hi|sauda√ß√µes)/i,
    agradecimento: /(obrigado|valeu|agrade√ßo|thanks|thank you)/i,
    buscarEventos: /(eventos?|shows?|festas?|encontrar|buscar|procurar|quero ir)/i,
    categorias: /(categorias?|tipos?|g√™neros?|estilos?|rock|funk|sertanejo|eletr√¥nica|pop|mpb)/i,
    localizacao: /(\b(em|no|na|de)\b |s√£o paulo|sp|rio|rj|minas|mg|bras√≠lia|df|curitiba|pr|porto alegre|rs)/i,
    preco: /(pre√ßo|valor|quanto custa|barato|caro|gr√°tis|gratuito|de gra√ßa|menor pre√ßo|mais barato|mais econ√¥mico|mais caro|maior pre√ßo|\b\d+\s*reais|\bR\$\s*\d+)/i,
    data: /(hoje|amanh√£|fim de semana|pr√≥ximos dias|semana que vem|m√™s que vem)/i,
    comprarIngresso: /(comprar|ingresso|entrada|bilhete|adquirir|como compro)/i,
    criarEvento: /(criar evento|publicar evento|cadastrar evento|anunciar evento)/i,
    perfil: /(perfil|minha conta|meus dados|editar perfil)/i,
    ajuda: /(ajuda|como funciona|help|suporte|d√∫vida)/i,
    sobre: /(quem √© voc√™|o que voc√™ faz|vibe bot|sua fun√ß√£o)/i,
    navegacao: /(me leve|me leve para|quero ir|acessar|ir para|ver (meus|o)|como (chego|acesso)) (perfil|carrinho|meus eventos|meus ingressos|cadastro|login|painel|admin|eventos|categorias|termos|d√∫vidas)/i,
    carrinho: /(carrinho|meu carrinho|itens do carrinho|compras|finalizar compra|remover item|deletar item|ver carrinho|limpar carrinho|esvaziar carrinho)/i,
    adicionarCarrinho: /(adicionar|comprar|colocar no carrinho|quero ingressos?)/i,
  };

  const intencaoDetectada = Object.keys(intencoes).find(key =>
    intencoes[key].test(mensagemLower)
  );

  const parametros = {};

  // Lista de categorias aceitas
  const categorias = [
    'rock', 'funk', 'sertanejo', 'eletr√¥nica', 'pop', 'mpb', 'forr√≥',
    'pagode', 'jazz', 'blues', 'cl√°ssica', 'teatro', 'dan√ßa',
    'stand-up', 'festival', 'infantil', 'esportes', 'gastronomia',
    'workshop', 'outros'
  ];

  // Verificar se alguma categoria aparece inteira na mensagem
  parametros.categoria = categorias.find(cat =>
    new RegExp(`\\b${cat}\\b`, 'i').test(mensagemLower)
  );

  const navegacaoRegex = /(me leve|me leve para|quero ir|acessar|ir para|ver (meus|o)|como (chego|acesso))/i;
  if (navegacaoRegex.test(mensagemLower)) {
    // Verificar se cont√©m destino de navega√ß√£o
    const destino = detectarDestinoNavegacao(mensagem);
    if (destino) {
      return {
        intent: 'navegacao',
        parameters: { destino },
        confidence: 0.9
      };
    }
  }

  const valorEspecifico = extrairValorMonetario(mensagem);
  if (valorEspecifico) {
    return {
      intent: 'preco',
      parameters: { ...parametros, valorEspecifico },
      confidence: 0.9
    };
  }

  const precoRegex = /(menor pre√ßo|mais barato|mais econ√¥mico|maior pre√ßo|mais caro)/i;
  if (precoRegex.test(mensagemLower)) {
    return {
      intent: 'preco',
      parameters: parametros,
      confidence: 0.9
    };
  }

  // Extrair localiza√ß√£o
  const locRegex = /(?:em|no|na|de)\s+([a-z√°√†√¢√£√©√®√™√≠√Ø√≥√¥√µ√∂√∫√ß√±]{3,})(?:\s*-\s*([a-z]{2}))?|(?:em|no|na|de)\s+([a-z]{2})\b/i;
  const matchLoc = mensagem.match(locRegex);

  if (matchLoc) {
    let cidadeDetectada = '';
    let estadoDetectado = '';

    if (matchLoc[1]) {
      cidadeDetectada = matchLoc[1].trim();
      estadoDetectado = matchLoc[2] ? matchLoc[2].toUpperCase() : null;
    }

    else if (matchLoc[3]) {
      estadoDetectado = matchLoc[3].toUpperCase();
    }

    const siglasEstados = ['AC', 'AL', 'AP', 'AM', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA',
      'MT', 'MS', 'MG', 'PA', 'PB', 'PR', 'PE', 'PI', 'RJ', 'RN',
      'RS', 'RO', 'RR', 'SC', 'SP', 'SE', 'TO'];

    if (estadoDetectado && siglasEstados.includes(estadoDetectado)) {
      parametros.localizacao = estadoDetectado;
    }

    else if (cidadeDetectada && estadoDetectado) {
      parametros.localizacao = cidadeDetectada + '-' + estadoDetectado;
    } else if (cidadeDetectada && !categorias.includes(cidadeDetectada.toLowerCase())) {
      parametros.localizacao = cidadeDetectada;
    }
  }

  // Processar inten√ß√µes de carrinho
  if (intencaoDetectada === 'carrinho') {
    // Verificar se √© para limpar o carrinho
    if (mensagemLower.includes('limpar') || mensagemLower.includes('esvaziar')) {
      return {
        intent: 'limparCarrinho',
        parameters: {},
        confidence: 0.9
      };
    }
    
    // Verificar se √© para finalizar compra
    if (mensagemLower.includes('finalizar') || mensagemLower.includes('comprar') || mensagemLower.includes('checkout')) {
      return {
        intent: 'finalizarCompra',
        parameters: {},
        confidence: 0.9
      };
    }
    
    // Verificar se √© para remover item espec√≠fico
    const removerRegex = /(remover|deletar|excluir).*?(item|ingresso)?\s*(\d+)/i;
    const matchRemover = mensagem.match(removerRegex);
    if (matchRemover && matchRemover[3]) {
      return {
        intent: 'removerItemCarrinho',
        parameters: { itemIndex: parseInt(matchRemover[3]) - 1 },
        confidence: 0.8
      };
    }
    
    return {
      intent: 'verCarrinho',
      parameters: {},
      confidence: 0.9
    };
  }

  if (intencaoDetectada === 'adicionarCarrinho') {
    // Extrair informa√ß√µes do evento para adicionar ao carrinho
    const eventoMatch = mensagem.match(/(?:adicionar|comprar).*?(\d+).*?(ingressos?)?/i);
    const quantidade = eventoMatch && eventoMatch[1] ? parseInt(eventoMatch[1]) : 1;
    
    return {
      intent: 'adicionarCarrinho',
      parameters: { 
        quantidade: quantidade,
      },
      confidence: 0.8
    };
  }

  // üîç LOG DE DEBUG
  console.log("üß© An√°lise da mensagem:", { intent: intencaoDetectada, parametros });

  return {
    intent: intencaoDetectada || 'outros',
    parameters: parametros,
    confidence: intencaoDetectada ? 0.8 : 0.3
  };
}

function detectarDestinoNavegacao(mensagem) {
  const mensagemLower = mensagem.toLowerCase();

  const mapeamentoDestinos = {
    'perfil': ['perfil', 'minha conta', 'meus dados'],
    'carrinho': ['carrinho', 'meu carrinho', 'compras', 'cesta'],
    'meus-eventos': ['meus eventos', 'eventos criados', 'meus shows'],
    'meus-ingressos': ['meus ingressos', 'ingressos comprados', 'minhas entradas'],
    'cadastro': ['cadastro', 'criar conta', 'registrar'],
    'login': ['login', 'entrar', 'acessar conta'],
    'painel': ['painel', 'admin', 'administra√ß√£o'],
    'home': ['home', 'in√≠cio', 'p√°gina inicial'],
    'categorias': ['categorias', 'tipos de evento'],
    'termos': ['termos', 'condi√ß√µes', 'pol√≠ticas'],
    'duvidas': ['d√∫vidas', 'ajuda', 'suporte', 'faq']
  };

  for (const [destino, palavrasChave] of Object.entries(mapeamentoDestinos)) {
    for (const palavra of palavrasChave) {
      if (mensagemLower.includes(palavra)) {
        return `/${destino}`;
      }
    }
  }

  return null;
}

// Fun√ß√µes para gerenciar carrinho
function gerenciarCarrinho(acao, parametros, carrinhoAtual = []) {
  let novoCarrinho = [...carrinhoAtual];
  let quickReplies = [];

  switch (acao) {
    case 'verCarrinho':
      if (novoCarrinho.length === 0) {
        return {
          textoResposta: "üõí Seu carrinho est√° vazio! Que tal explorar alguns eventos? üé™",
          carrinho: novoCarrinho,
          quickReplies: [
            { text: "üé™ Ver eventos", action: "verEventos" }
          ]
        };
      } else {
        const total = novoCarrinho.reduce((acc, item) => acc + (item.preco * item.quantidade), 0);
        
        let textoResposta = "üõí **Seu Carrinho:**\n\n";
        novoCarrinho.forEach((item, index) => {
          textoResposta += `${index + 1}. **${item.nomeEvento}**\n`;
          textoResposta += `   üìÖ ${item.dataEvento}\n`;
          textoResposta += `   üé´ ${item.quantidade}x R$ ${item.preco.toFixed(2)}\n`;
          textoResposta += `   üí∞ Subtotal: R$ ${(item.preco * item.quantidade).toFixed(2)}\n\n`;
        });
        textoResposta += `**üí∞ TOTAL: R$ ${total.toFixed(2)}**`;
        
        return {
          textoResposta: textoResposta,
          carrinho: novoCarrinho,
          quickReplies: [
            { text: "üóëÔ∏è Remover item", action: "removerItem" },
            { text: "üßπ Limpar carrinho", action: "limparCarrinho" },
            { text: "‚úÖ Finalizar compra", action: "finalizarCompra" }
          ]
        };
      }

    case 'limparCarrinho':
      novoCarrinho = [];
      return {
        textoResposta: "üßπ Carrinho limpo com sucesso! Todos os itens foram removidos.",
        carrinho: novoCarrinho,
        quickReplies: [
          { text: "üé™ Ver eventos", action: "verEventos" }
        ]
      };

    case 'removerItemCarrinho':
      const itemIndex = parametros.itemIndex;
      if (itemIndex >= 0 && itemIndex < novoCarrinho.length) {
        const itemRemovido = novoCarrinho[itemIndex];
        novoCarrinho.splice(itemIndex, 1);
        return {
          textoResposta: `üóëÔ∏è "${itemRemovido.nomeEvento}" removido do carrinho!`,
          carrinho: novoCarrinho,
          quickReplies: [
            { text: "üõí Ver carrinho", action: "verCarrinho" },
            { text: "üé™ Continuar comprando", action: "verEventos" }
          ]
        };
      }
      break;

    case 'finalizarCompra':
      if (novoCarrinho.length === 0) {
        return {
          textoResposta: "üõí Seu carrinho est√° vazio! Adicione alguns eventos antes de finalizar a compra.",
          carrinho: novoCarrinho,
          quickReplies: [
            { text: "üé™ Ver eventos", action: "verEventos" }
          ]
        };
      } else {
        return {
          textoResposta: "‚úÖ Te levando para finalizar sua compra... üöÄ",
          carrinho: novoCarrinho,
          navegarPara: "/carrinho"
        };
      }

    default:
      break;
  }

  return {
    textoResposta: "",
    carrinho: novoCarrinho,
    quickReplies: []
  };
}

// Rota principal do chatbot
router.post('/chat', async (req, res) => {
  try {
    const { message, state = {}, carrinho = [] } = req.body;
    const userId = req.headers['user-id'];

    if (!message) {
      return res.status(400).json({
        success: false,
        error: 'Mensagem √© obrigat√≥ria'
      });
    }

    const mensagemLower = message.toLowerCase();

    // Analisar a mensagem do usu√°rio
    const analise = analisarMensagem(message);

    let eventos = [];
    let categoriasDisponiveis = [];
    let showCommands = true;
    let novoEstado = { ...state };
    let quickReplies = [];
    let textoResposta = "";
    let carrinhoAtual = [...carrinho];
    let navegarPara = null;

    // Processar com base na inten√ß√£o detectada
    switch (analise.intent) {
      case 'navegacao':
        console.log("üß≠ Inten√ß√£o de navega√ß√£o detectada");
        const destino = detectarDestinoNavegacao(message);
        console.log("üéØ Destino detectado:", destino);

        if (destino) {
          novoEstado.navegarPara = destino;
          console.log("üìç Comando de navega√ß√£o adicionado:", destino);

          eventos = [];
          categoriasDisponiveis = [];
          showCommands = false;
          break;
        }
        break;

      case 'verCarrinho':
      case 'limparCarrinho':
      case 'removerItemCarrinho':
      case 'finalizarCompra':
        const resultadoCarrinho = gerenciarCarrinho(analise.intent, analise.parameters, carrinhoAtual);
        textoResposta = resultadoCarrinho.textoResposta;
        carrinhoAtual = resultadoCarrinho.carrinho;
        quickReplies = resultadoCarrinho.quickReplies || [];
        navegarPara = resultadoCarrinho.navegarPara;
        showCommands = false;
        break;

      case 'buscarEventos':
        const filtros = { ...state, ...analise.parameters };
        eventos = await buscarEventos(filtros);
        novoEstado = filtros;

        if (eventos.length > 0) {
          showCommands = false;
        }
        break;

      case 'preco':
        const filtrosPreco = { ...state };

        if (analise.parameters.valorEspecifico) {
          filtrosPreco.valorEspecifico = analise.parameters.valorEspecifico;
        }
        else if (mensagemLower.includes('menor') || mensagemLower.includes('barato')) {
          filtrosPreco.faixaPreco = { min: 0, max: 50 };
        } else if (mensagemLower.includes('caro') || mensagemLower.includes('maior')) {
          filtrosPreco.faixaPreco = { min: 100, max: 1000 };
        }

        eventos = await buscarEventos({
          ...filtrosPreco,
          ...analise.parameters,
          intent: 'preco'
        });

        showCommands = eventos.length === 0;
        break;

      case 'categorias':
        const categoriasUnicas = await Event.distinct('categoria', { status: 'aprovado' });
        categoriasDisponiveis = categoriasUnicas.filter(cat => cat).sort();
        break;

      case 'localizacao':
        novoEstado.localizacao = analise.parameters.localizacao;
        eventos = await buscarEventos(novoEstado);
        break;

      default:
        if (Object.keys(novoEstado).length > 0) {
          eventos = await buscarEventos(novoEstado);
        }
    }

    // Se j√° temos uma resposta do carrinho, usar ela
    if (!textoResposta) {
      // Preparar contexto para o modelo
      const contexto = `
        Estado atual: ${JSON.stringify(novoEstado)}
        Eventos encontrados: ${eventos.length}
        ${eventos.length > 0 ? `Exemplo de evento: ${eventos[0].nome} em ${eventos[0].cidade}` : ''}
        Categorias dispon√≠veis: ${categoriasDisponiveis.join(', ')}
        Carrinho atual: ${carrinhoAtual.length} itens
        ${carrinhoAtual.length > 0 ? `Itens no carrinho: ${carrinhoAtual.map(item => item.nomeEvento).join(', ')}` : ''}
      `.trim();

      // Chamar o modelo usando a nova API InferenceClient
      const chatCompletion = await client.chatCompletion({
        provider: "cerebras",
        model: "openai/gpt-oss-120b",
        messages: [
          {
            role: "system",
            content: SYSTEM_PROMPT
          },
          {
            role: "user",
            content: `Contexto: ${contexto}\n\nMensagem do usu√°rio: ${message}`
          }
        ],
        max_tokens: 500,
        temperature: 0.7
      });

      textoResposta = chatCompletion.choices[0].message.content;
    }

    // Construir resposta
    const resposta = {
      success: true,
      reply: {
        text: textoResposta,
        intent: analise.intent,
        confidence: analise.confidence,
        eventos: eventos.slice(0, 5),
        categorias: categoriasDisponiveis,
        showCommands: showCommands,
        state: { ...novoEstado, ...(navegarPara && { navegarPara }) },
        quickReplies: quickReplies,
        carrinho: carrinhoAtual
      },
      categorias: categoriasDisponiveis
    };

    res.json(resposta);

  } catch (error) {
    console.error('Erro no processamento do chatbot:', error);

    // Resposta de fallback
    res.json({
      success: true,
      reply: {
        text: "E a√≠! üëã Bora subir essa vibe hoje? Sou o Vibe Bot e posso te ajudar a encontrar os melhores eventos! üéµ\n\nO que voc√™ est√° a fim de curtir? Pode me perguntar sobre eventos, categorias, ou como funciona a plataforma! üòé",
        showCommands: true,
        state: state
      }
    });
  }
});

// Rota para obter categorias dispon√≠veis
router.get('/categorias', async (req, res) => {
  try {
    const categorias = await Event.distinct('categoria', { status: 'aprovado' });
    res.json({
      success: true,
      categorias: categorias.filter(cat => cat).sort()
    });
  } catch (error) {
    console.error('Erro ao buscar categorias:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao buscar categorias'
    });
  }
});

module.exports = router;
